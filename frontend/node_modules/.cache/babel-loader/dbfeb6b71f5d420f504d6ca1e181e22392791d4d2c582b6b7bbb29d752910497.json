{"ast":null,"code":"var _jsxFileName = \"E:\\\\Competition\\\\Hackathon\\\\Fixpoint_javafest\\\\FixPoint\\\\frontend\\\\src\\\\contexts\\\\ChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useRef, useState } from \"react\";\nimport SockJS from \"sockjs-client\";\nimport { CompatClient, Stomp } from \"@stomp/stompjs\";\nimport api from \"../services/api\";\nimport { useAuth } from \"./AuthContext\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WS_URL = \"/ws-chat\";\nconst API_USERS = \"/api/chat/users\";\nconst ChatContext = /*#__PURE__*/createContext();\nexport const useChat = () => {\n  _s();\n  return useContext(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [users, setUsers] = useState([]);\n  const [messages, setMessages] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const stompClientRef = useRef(null);\n  const selectedUserRef = useRef(null);\n\n  // Keep selectedUserRef in sync\n  useEffect(() => {\n    selectedUserRef.current = selectedUser;\n  }, [selectedUser]);\n\n  // Fetch user list\n  useEffect(() => {\n    if (user) {\n      let cancelled = false;\n      api.get(API_USERS).then(res => {\n        var _res$data;\n        const list = Array.isArray(res.data) ? res.data : Array.isArray((_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.users) ? res.data.users : [];\n        if (!cancelled && user) {\n          setUsers(list.filter(u => u.id !== user.id));\n        }\n      }).catch(err => {\n        if (!cancelled) {\n          console.error(\"Failed to fetch chat users:\", err);\n          setUsers([]);\n        }\n      });\n      return () => {\n        cancelled = true;\n      };\n    } else {\n      setUsers([]);\n    }\n  }, [user]);\n\n  // Connect to WebSocket only once\n  useEffect(() => {\n    if (!user) return;\n    const socket = new SockJS(WS_URL);\n    const client = Stomp.over(socket);\n    setIsConnected(false);\n    client.connect({}, () => {\n      setIsConnected(true);\n      client.subscribe(`/user/${user.username}/queue/messages`, msg => {\n        const body = JSON.parse(msg.body);\n        // Only add message if it is between the logged-in user and the selected user (using ref)\n        setMessages(prev => {\n          const selUser = selectedUserRef.current;\n          if (!selUser) return prev;\n          const isBetween = body.sender.id === user.id && body.receiver.id === selUser.id || body.sender.id === selUser.id && body.receiver.id === user.id;\n          if (isBetween) {\n            return [...prev, body];\n          }\n          return prev;\n        });\n      });\n    }, err => {\n      setIsConnected(false);\n      console.error(\"STOMP connection error:\", err);\n    });\n    stompClientRef.current = client;\n    return () => {\n      client.disconnect();\n      setIsConnected(false);\n    };\n  }, [user]);\n\n  // Fetch chat history when selected user changes\n  useEffect(() => {\n    if (selectedUser) {\n      api.get(`/api/chat/history?userId=${selectedUser.id}`).then(res => {\n        setMessages(res.data);\n      }).catch(err => {\n        var _err$response, _err$response$data, _err$response2;\n        setMessages([]);\n        const backendMsg = (err === null || err === void 0 ? void 0 : (_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.message) || (err === null || err === void 0 ? void 0 : (_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : _err$response2.data) || err.message;\n        console.error(\"Failed to fetch chat history:\", backendMsg);\n        alert(\"Failed to load chat history. Backend says: \" + backendMsg);\n      });\n    } else {\n      setMessages([]);\n    }\n  }, [selectedUser]);\n  const sendMessage = content => {\n    if (!content.trim() || !selectedUser || !isConnected || !stompClientRef.current) return;\n    try {\n      const msg = {\n        content,\n        receiver: {\n          id: selectedUser.id\n        },\n        type: \"TEXT\",\n        sender: {\n          id: user.id\n        }\n      };\n      // Optimistically add the message to the chat\n      setMessages(prev => [...prev, {\n        ...msg,\n        sender: {\n          id: user.id\n        },\n        receiver: {\n          id: selectedUser.id\n        }\n      }]);\n      stompClientRef.current.send(\"/app/chat.send\", {}, JSON.stringify(msg));\n    } catch (err) {\n      alert(\"Unable to send message: STOMP connection not ready.\");\n      console.error(\"Send message error:\", err);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      users,\n      messages,\n      selectedUser,\n      setSelectedUser,\n      sendMessage,\n      isConnected\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 150,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"GNB+bdKM2BKIhsWSakUE1SbSLc0=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useRef","useState","SockJS","CompatClient","Stomp","api","useAuth","jsxDEV","_jsxDEV","WS_URL","API_USERS","ChatContext","useChat","_s","ChatProvider","children","_s2","user","users","setUsers","messages","setMessages","selectedUser","setSelectedUser","isConnected","setIsConnected","stompClientRef","selectedUserRef","current","cancelled","get","then","res","_res$data","list","Array","isArray","data","filter","u","id","catch","err","console","error","socket","client","over","connect","subscribe","username","msg","body","JSON","parse","prev","selUser","isBetween","sender","receiver","disconnect","_err$response","_err$response$data","_err$response2","backendMsg","response","message","alert","sendMessage","content","trim","type","send","stringify","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/Competition/Hackathon/Fixpoint_javafest/FixPoint/frontend/src/contexts/ChatContext.js"],"sourcesContent":["import React, {\r\n  createContext,\r\n  useContext,\r\n  useEffect,\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport SockJS from \"sockjs-client\";\r\nimport { CompatClient, Stomp } from \"@stomp/stompjs\";\r\nimport api from \"../services/api\";\r\nimport { useAuth } from \"./AuthContext\";\r\n\r\nconst WS_URL = \"/ws-chat\";\r\nconst API_USERS = \"/api/chat/users\";\r\n\r\nconst ChatContext = createContext();\r\n\r\nexport const useChat = () => useContext(ChatContext);\r\n\r\nexport const ChatProvider = ({ children }) => {\r\n  const { user } = useAuth();\r\n  const [users, setUsers] = useState([]);\r\n  const [messages, setMessages] = useState([]);\r\n  const [selectedUser, setSelectedUser] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const stompClientRef = useRef(null);\r\n  const selectedUserRef = useRef(null);\r\n\r\n  // Keep selectedUserRef in sync\r\n  useEffect(() => {\r\n    selectedUserRef.current = selectedUser;\r\n  }, [selectedUser]);\r\n\r\n  // Fetch user list\r\n  useEffect(() => {\r\n    if (user) {\r\n      let cancelled = false;\r\n      api\r\n        .get(API_USERS)\r\n        .then((res) => {\r\n          const list = Array.isArray(res.data)\r\n            ? res.data\r\n            : Array.isArray(res.data?.users)\r\n            ? res.data.users\r\n            : [];\r\n          if (!cancelled && user) {\r\n            setUsers(list.filter((u) => u.id !== user.id));\r\n          }\r\n        })\r\n        .catch((err) => {\r\n          if (!cancelled) {\r\n            console.error(\"Failed to fetch chat users:\", err);\r\n            setUsers([]);\r\n          }\r\n        });\r\n      return () => {\r\n        cancelled = true;\r\n      };\r\n    } else {\r\n      setUsers([]);\r\n    }\r\n  }, [user]);\r\n\r\n  // Connect to WebSocket only once\r\n  useEffect(() => {\r\n    if (!user) return;\r\n    const socket = new SockJS(WS_URL);\r\n    const client = Stomp.over(socket);\r\n    setIsConnected(false);\r\n    client.connect(\r\n      {},\r\n      () => {\r\n        setIsConnected(true);\r\n        client.subscribe(`/user/${user.username}/queue/messages`, (msg) => {\r\n          const body = JSON.parse(msg.body);\r\n          // Only add message if it is between the logged-in user and the selected user (using ref)\r\n          setMessages((prev) => {\r\n            const selUser = selectedUserRef.current;\r\n            if (!selUser) return prev;\r\n            const isBetween =\r\n              (body.sender.id === user.id && body.receiver.id === selUser.id) ||\r\n              (body.sender.id === selUser.id && body.receiver.id === user.id);\r\n            if (isBetween) {\r\n              return [...prev, body];\r\n            }\r\n            return prev;\r\n          });\r\n        });\r\n      },\r\n      (err) => {\r\n        setIsConnected(false);\r\n        console.error(\"STOMP connection error:\", err);\r\n      }\r\n    );\r\n    stompClientRef.current = client;\r\n    return () => {\r\n      client.disconnect();\r\n      setIsConnected(false);\r\n    };\r\n  }, [user]);\r\n\r\n  // Fetch chat history when selected user changes\r\n  useEffect(() => {\r\n    if (selectedUser) {\r\n      api\r\n        .get(`/api/chat/history?userId=${selectedUser.id}`)\r\n        .then((res) => {\r\n          setMessages(res.data);\r\n        })\r\n        .catch((err) => {\r\n          setMessages([]);\r\n          const backendMsg =\r\n            err?.response?.data?.message || err?.response?.data || err.message;\r\n          console.error(\"Failed to fetch chat history:\", backendMsg);\r\n          alert(\"Failed to load chat history. Backend says: \" + backendMsg);\r\n        });\r\n    } else {\r\n      setMessages([]);\r\n    }\r\n  }, [selectedUser]);\r\n\r\n  const sendMessage = (content) => {\r\n    if (\r\n      !content.trim() ||\r\n      !selectedUser ||\r\n      !isConnected ||\r\n      !stompClientRef.current\r\n    )\r\n      return;\r\n    try {\r\n      const msg = {\r\n        content,\r\n        receiver: { id: selectedUser.id },\r\n        type: \"TEXT\",\r\n        sender: { id: user.id },\r\n      };\r\n      // Optimistically add the message to the chat\r\n      setMessages((prev) => [\r\n        ...prev,\r\n        { ...msg, sender: { id: user.id }, receiver: { id: selectedUser.id } },\r\n      ]);\r\n      stompClientRef.current.send(\"/app/chat.send\", {}, JSON.stringify(msg));\r\n    } catch (err) {\r\n      alert(\"Unable to send message: STOMP connection not ready.\");\r\n      console.error(\"Send message error:\", err);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ChatContext.Provider\r\n      value={{\r\n        users,\r\n        messages,\r\n        selectedUser,\r\n        setSelectedUser,\r\n        sendMessage,\r\n        isConnected,\r\n      }}\r\n    >\r\n      {children}\r\n    </ChatContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}