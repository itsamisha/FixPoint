{"ast":null,"code":"var _jsxFileName = \"E:\\\\Competition\\\\Hackathon\\\\Fixpoint_javafest\\\\FixPoint\\\\frontend\\\\src\\\\contexts\\\\ChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useRef, useState } from 'react';\nimport SockJS from 'sockjs-client';\nimport { CompatClient, Stomp } from '@stomp/stompjs';\nimport api from '../services/api';\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WS_URL = '/ws-chat';\nconst API_USERS = '/api/chat/users';\nconst ChatContext = /*#__PURE__*/createContext();\nexport const useChat = () => {\n  _s();\n  return useContext(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [users, setUsers] = useState([]);\n  const [messages, setMessages] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const stompClientRef = useRef(null);\n  const selectedUserRef = useRef(null);\n\n  // Keep selectedUserRef in sync\n  useEffect(() => {\n    selectedUserRef.current = selectedUser;\n  }, [selectedUser]);\n\n  // Fetch user list\n  useEffect(() => {\n    if (user) {\n      api.get(API_USERS).then(res => {\n        setUsers(res.data.filter(u => u.id !== user.id));\n      });\n    }\n  }, [user]);\n\n  // Connect to WebSocket only once\n  useEffect(() => {\n    if (!user) return;\n    const socket = new SockJS(WS_URL);\n    const client = Stomp.over(socket);\n    setIsConnected(false);\n    client.connect({}, () => {\n      setIsConnected(true);\n      client.subscribe(`/user/${user.username}/queue/messages`, msg => {\n        const body = JSON.parse(msg.body);\n        // Only add message if it is between the logged-in user and the selected user (using ref)\n        setMessages(prev => {\n          const selUser = selectedUserRef.current;\n          if (!selUser) return prev;\n          const isBetween = body.sender.id === user.id && body.receiver.id === selUser.id || body.sender.id === selUser.id && body.receiver.id === user.id;\n          if (isBetween) {\n            return [...prev, body];\n          }\n          return prev;\n        });\n      });\n    }, err => {\n      setIsConnected(false);\n      console.error('STOMP connection error:', err);\n    });\n    stompClientRef.current = client;\n    return () => {\n      client.disconnect();\n      setIsConnected(false);\n    };\n  }, [user]);\n\n  // Fetch chat history when selected user changes\n  useEffect(() => {\n    if (selectedUser) {\n      api.get(`/api/chat/history?userId=${selectedUser.id}`).then(res => {\n        setMessages(res.data);\n      }).catch(err => {\n        var _err$response, _err$response$data, _err$response2;\n        setMessages([]);\n        const backendMsg = (err === null || err === void 0 ? void 0 : (_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.message) || (err === null || err === void 0 ? void 0 : (_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : _err$response2.data) || err.message;\n        console.error('Failed to fetch chat history:', backendMsg);\n        alert('Failed to load chat history. Backend says: ' + backendMsg);\n      });\n    } else {\n      setMessages([]);\n    }\n  }, [selectedUser]);\n  const sendMessage = content => {\n    if (!content.trim() || !selectedUser || !isConnected || !stompClientRef.current) return;\n    try {\n      const msg = {\n        content,\n        receiver: {\n          id: selectedUser.id\n        },\n        type: 'TEXT',\n        sender: {\n          id: user.id\n        }\n      };\n      // Optimistically add the message to the chat\n      setMessages(prev => [...prev, {\n        ...msg,\n        sender: {\n          id: user.id\n        },\n        receiver: {\n          id: selectedUser.id\n        }\n      }]);\n      stompClientRef.current.send('/app/chat.send', {}, JSON.stringify(msg));\n    } catch (err) {\n      alert('Unable to send message: STOMP connection not ready.');\n      console.error('Send message error:', err);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      users,\n      messages,\n      selectedUser,\n      setSelectedUser,\n      sendMessage,\n      isConnected\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 108,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"GNB+bdKM2BKIhsWSakUE1SbSLc0=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useRef","useState","SockJS","CompatClient","Stomp","api","useAuth","jsxDEV","_jsxDEV","WS_URL","API_USERS","ChatContext","useChat","_s","ChatProvider","children","_s2","user","users","setUsers","messages","setMessages","selectedUser","setSelectedUser","isConnected","setIsConnected","stompClientRef","selectedUserRef","current","get","then","res","data","filter","u","id","socket","client","over","connect","subscribe","username","msg","body","JSON","parse","prev","selUser","isBetween","sender","receiver","err","console","error","disconnect","catch","_err$response","_err$response$data","_err$response2","backendMsg","response","message","alert","sendMessage","content","trim","type","send","stringify","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/Competition/Hackathon/Fixpoint_javafest/FixPoint/frontend/src/contexts/ChatContext.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useRef, useState } from 'react';\r\nimport SockJS from 'sockjs-client';\r\nimport { CompatClient, Stomp } from '@stomp/stompjs';\r\nimport api from '../services/api';\r\nimport { useAuth } from './AuthContext';\r\n\r\nconst WS_URL = '/ws-chat';\r\nconst API_USERS = '/api/chat/users';\r\n\r\nconst ChatContext = createContext();\r\n\r\nexport const useChat = () => useContext(ChatContext);\r\n\r\nexport const ChatProvider = ({ children }) => {\r\n  const { user } = useAuth();\r\n  const [users, setUsers] = useState([]);\r\n  const [messages, setMessages] = useState([]);\r\n  const [selectedUser, setSelectedUser] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const stompClientRef = useRef(null);\r\n  const selectedUserRef = useRef(null);\r\n\r\n  // Keep selectedUserRef in sync\r\n  useEffect(() => {\r\n    selectedUserRef.current = selectedUser;\r\n  }, [selectedUser]);\r\n\r\n  // Fetch user list\r\n  useEffect(() => {\r\n    if (user) {\r\n      api.get(API_USERS).then(res => {\r\n        setUsers(res.data.filter(u => u.id !== user.id));\r\n      });\r\n    }\r\n  }, [user]);\r\n\r\n  // Connect to WebSocket only once\r\n  useEffect(() => {\r\n    if (!user) return;\r\n    const socket = new SockJS(WS_URL);\r\n    const client = Stomp.over(socket);\r\n    setIsConnected(false);\r\n    client.connect({}, () => {\r\n      setIsConnected(true);\r\n      client.subscribe(`/user/${user.username}/queue/messages`, (msg) => {\r\n        const body = JSON.parse(msg.body);\r\n        // Only add message if it is between the logged-in user and the selected user (using ref)\r\n        setMessages(prev => {\r\n          const selUser = selectedUserRef.current;\r\n          if (!selUser) return prev;\r\n          const isBetween =\r\n            (body.sender.id === user.id && body.receiver.id === selUser.id) ||\r\n            (body.sender.id === selUser.id && body.receiver.id === user.id);\r\n          if (isBetween) {\r\n            return [...prev, body];\r\n          }\r\n          return prev;\r\n        });\r\n      });\r\n    }, (err) => {\r\n      setIsConnected(false);\r\n      console.error('STOMP connection error:', err);\r\n    });\r\n    stompClientRef.current = client;\r\n    return () => {\r\n      client.disconnect();\r\n      setIsConnected(false);\r\n    };\r\n  }, [user]);\r\n\r\n  // Fetch chat history when selected user changes\r\n  useEffect(() => {\r\n    if (selectedUser) {\r\n      api.get(`/api/chat/history?userId=${selectedUser.id}`)\r\n        .then(res => {\r\n          setMessages(res.data);\r\n        })\r\n        .catch(err => {\r\n          setMessages([]);\r\n          const backendMsg = err?.response?.data?.message || err?.response?.data || err.message;\r\n          console.error('Failed to fetch chat history:', backendMsg);\r\n          alert('Failed to load chat history. Backend says: ' + backendMsg);\r\n        });\r\n    } else {\r\n      setMessages([]);\r\n    }\r\n  }, [selectedUser]);\r\n\r\n  const sendMessage = (content) => {\r\n    if (!content.trim() || !selectedUser || !isConnected || !stompClientRef.current) return;\r\n    try {\r\n      const msg = {\r\n        content,\r\n        receiver: { id: selectedUser.id },\r\n        type: 'TEXT',\r\n        sender: { id: user.id },\r\n      };\r\n      // Optimistically add the message to the chat\r\n      setMessages(prev => [...prev, { ...msg, sender: { id: user.id }, receiver: { id: selectedUser.id } }]);\r\n      stompClientRef.current.send('/app/chat.send', {}, JSON.stringify(msg));\r\n    } catch (err) {\r\n      alert('Unable to send message: STOMP connection not ready.');\r\n      console.error('Send message error:', err);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ChatContext.Provider value={{\r\n      users,\r\n      messages,\r\n      selectedUser,\r\n      setSelectedUser,\r\n      sendMessage,\r\n      isConnected,\r\n    }}>\r\n      {children}\r\n    </ChatContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}